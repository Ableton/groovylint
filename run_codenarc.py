#!/bin/env python3
#
# Copyright (c) 2019 Ableton AG, Berlin. All rights reserved.
#
# Use of this source code is governed by a MIT-style
# license that can be found in the LICENSE file.

"""A small wrapper script to call CodeNarc and interpret its output."""

import os
import subprocess
import sys
import xmltodict


DEFAULT_REPORT_FILE = 'codenarc-report.xml'


def _print_violations(package_file_path, violations):
    for violation in violations:
        violation_message = f'{violation["@ruleName"]}: {violation["Message"]}'
        print(f'{package_file_path}:{violation["@lineNumber"]}: {violation_message}')


def _print_violations_in_file(package_path, files):
    for package_file in files:
        _print_violations(
            f'{package_path}/{package_file["@name"]}',
            _safe_list_wrapper(package_file["Violation"]),
        )


def _print_violations_in_package(packages):
    # I believe that CodeNarc has a bug where it erroneously sets filesWithViolations
    # to the same value in every package. Therefore rather than looking at this attribute
    # value, we check to see if there are any File elements in the package.
    for package in [p for p in packages if 'Files' in p]:
        # CodeNarc uses the empty string for the top-level package, which we translate to
        # '.', which prevents the violation files from appearing as belonging to '/'.
        package_path = package["@path"]
        if not package_path:
            package_path = '.'

        _print_violations_in_file(package_path, _safe_list_wrapper(package["File"]))


def _remove_report_file(report_file):
    if os.path.exists(report_file):
        os.remove(report_file)


def _safe_list_wrapper(element):
    """Wrap an XML element in a list if necessary.

    This function is used to safely handle data from xmltodict. If an XML element has
    multiple children, they will be returned in a list. However, a single child is
    returned as a dict. By wrapping single elements in a list, we can use the same code to
    handle both cases.
    """
    return element if isinstance(element, list) else [element]


def parse_xml_report(xml_text):
    """Parse XML report text generated by CodeNarc.

    :param xml_text: Raw XML text of CodeNarc report.
    :return: 0 on success, 1 if any violations were found
    """
    xml_doc = xmltodict.parse(xml_text)

    package_summary = xml_doc['CodeNarc']['PackageSummary']
    total_files_scanned = package_summary['@totalFiles']
    total_violations = package_summary['@filesWithViolations']

    print(f'Scanned {total_files_scanned} files')
    if total_violations == '0':
        print('No violations found')
        return 0

    print(f'Found {total_violations} violation(s):')
    _print_violations_in_package(_safe_list_wrapper(xml_doc["CodeNarc"]["Package"]))
    return 1


def run_codenarc(args, report_file=DEFAULT_REPORT_FILE):
    """Run CodeNarc on specified code.

    :param args: Command line arguments to be passed to CodeNarc.
    :param report_file: Name of report file to generate.
    :return: Raw XML text report generated by CodeNarc.
    """
    # -rulesetfiles must not be an absolute path, only a relative one to the CLASSPATH
    codenarc_call = [
        '/usr/bin/codenarc.sh',
        '-rulesetfiles=ruleset.groovy',
        f'-report=xml:{report_file}',
    ] + args

    output = subprocess.run(
        codenarc_call,
        stderr=subprocess.STDOUT,
        stdout=subprocess.PIPE,
    )
    sys.stdout.buffer.write(output.stdout)

    # CodeNarc doesn't fail on compilation errors, it just logs a message for each file
    # that could not be compiled and generates a report for everything else. It also does
    # not return a non-zero code in such cases. For our purposes, we want to treat syntax
    # errors (and similar problems) as a failure condition.
    if 'Compilation failed' in str(output.stdout):
        _remove_report_file(report_file)
        raise ValueError('Error when compiling files!')

    if output.returncode != 0:
        _remove_report_file(report_file)
        raise ValueError(f'CodeNarc failed with return code {output.returncode}')
    if not os.path.exists(report_file):
        _remove_report_file(report_file)
        raise ValueError(f'{report_file} was not generated, aborting!')

    with open(report_file) as xml_file:
        xml_text = xml_file.read()
    _remove_report_file(report_file)

    return xml_text


if __name__ == '__main__':
    sys.exit(parse_xml_report(run_codenarc(sys.argv[1:])))
