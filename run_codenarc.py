#!/usr/bin/env python3
#
# Copyright (c) 2019 Ableton AG, Berlin. All rights reserved.
#
# Use of this source code is governed by a MIT-style
# license that can be found in the LICENSE file.

"""A small wrapper script to call CodeNarc and interpret its output."""

import argparse
import logging
import os
import platform
import subprocess
import sys

from xml.etree import ElementTree


DEFAULT_REPORT_FILE = 'codenarc-report.xml'


class CodeNarcViolationsException(Exception):
    """Raised if CodeNarc violations were found."""

    def __init__(self, num_violations):
        """Create a new instance of the CodeNarcViolationsException class."""
        super().__init__()
        self.num_violations = num_violations


def _build_classpath(args):
    """Construct the classpath from the Groovy/Groovylint homes and JAR versions."""
    classpath = [
        args.home,
        f'{args.groovy_home}/lib/*',
        f'{args.home}/CodeNarc-{args.codenarc_version}.jar',
        f'{args.home}/GMetrics-{args.gmetrics_version}.jar',
        f'{args.home}/slf4j-api-{args.slf4j_version}.jar',
        f'{args.home}/slf4j-simple-{args.slf4j_version}.jar',
    ]

    for path in classpath:
        if not (os.path.exists(path) or path.endswith('*')):
            raise ValueError(f'Classpath element {path} does not exist')

    return ':'.join(classpath)


def _guess_groovy_home():
    """Try to determine the location where Groovy is installed.

    :return: Path of the Groovy installation, or None if it can't be determined.
    """
    if 'GROOVY_HOME' in os.environ:
        return os.environ['GROOVY_HOME']

    if platform.system() == 'Darwin':
        brew_groovy_home = '/usr/local/opt/groovysdk/libexec'
        if os.path.exists(brew_groovy_home):
            return brew_groovy_home

    return None


def _is_slf4j_line(line):
    """Determine if a log line was produced by SLF4J.

    CodeNarc in some cases prints things to stdout, or uses multi-line logging calls which
    cannot be parsed correctly when we attempt to re-log them in _log_codenarc_output.
    """
    return isinstance(logging.getLevelName(line.split(' ')[0]), int)


def _log_codenarc_output(lines):
    """Re-log lines from CodeNarc's output.

    This function takes a log line generated by CodeNarc and re-logs it with the logging
    framework. We take the log level, which is the first word of the line output, which
    can be used to determine the corresponding log level in Python's logging framework.
    """
    log_level = logging.INFO
    for line in lines:
        line_words = line.split(' ')
        if _is_slf4j_line(line):
            log_level = logging.getLevelName(line_words[0])
            log_message = ' '.join(line_words[1:])
        else:
            # If we can't determine the log level, that likely means that this line is a
            # continuation of the previous line. This occurs when CodeNarc is logging
            # compilation messages, stacktraces, etc. In these cases, we should use the
            # same logging level as the last known line. Also, here we need to log the
            # entire line and not chop off the first word.
            log_message = line

        logging.log(log_level, log_message)


def _print_violations(package_file_path, violations):
    """Print violations for a file.

    :param package_file_path: File path.
    :param violations: List of Violation elements.
    :return: Number of violations for the file.
    """
    for violation in violations:
        message_element = violation.find('Message')
        message = message_element.text if message_element else '[empty message]'
        logging.error(
            '%s:%s: %s: %s',
            package_file_path,
            violation.attrib['lineNumber'],
            violation.attrib['ruleName'],
            message,
        )

    return len(violations)


def _print_violations_in_files(package_path, files):
    """Print violations for each file in a package.

    :param package_path: Package path.
    :param files: List of File elements.
    :return: Number of violations for all files in the package.
    """
    num_violations = 0

    for package_file in files:
        package_file_name = f'{package_path}/{package_file.attrib["name"]}'
        logging.debug('Parsing violations in file: %s', package_file_name)
        num_violations += _print_violations(
            package_file_name, package_file.findall('Violation')
        )

    return num_violations


def _print_violations_in_packages(packages):
    """Print violations for each package in a list of packages.

    :param packages: List of Package elements.
    :return: Number of violations for all packages.
    """
    num_violations = 0

    for package in packages:
        # CodeNarc uses the empty string for the top-level package, which we translate to
        # '.', which prevents the violation files from appearing as belonging to '/'.
        package_path = package.attrib['path']
        if not package_path:
            package_path = '.'

        logging.debug('Parsing violations in package: %s', package_path)
        num_violations += _print_violations_in_files(
            package_path, package.findall('File')
        )

    return num_violations


def _remove_report_file(report_file):
    if os.path.exists(report_file):
        logging.debug('Removing report file %s', report_file)
        os.remove(report_file)


def parse_args(args):
    """Parse arguments from the command line."""
    arg_parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    arg_parser.add_argument(
        '--codenarc-version',
        default=os.environ.get('CODENARC_VERSION'),
        help='CodeNarc version to use',
    )

    arg_parser.add_argument(
        '--gmetrics-version',
        default=os.environ.get('GMETRICS_VERSION'),
        help='GMetrics version to use',
    )

    arg_parser.add_argument(
        '--groovy-home', default=_guess_groovy_home(), help='Groovy home directory'
    )

    arg_parser.add_argument(
        '--home',
        default=os.path.realpath(os.path.dirname(__file__)),
        help='Groovylint home directory',
    )

    arg_parser.add_argument(
        '--slf4j-version',
        default=os.environ.get('SLF4J_VERSION'),
        help='SLF4J version to use',
    )

    arg_parser.add_argument(
        '-q',
        '--quiet',
        action='store_const',
        const=logging.WARN,
        dest='log_level',
        help='Show less output',
    )

    arg_parser.add_argument(
        '-v',
        '--verbose',
        action='store_const',
        const=logging.DEBUG,
        dest='log_level',
        help='Show extra output',
    )

    arg_parser.add_argument(
        'codenarc_options',
        nargs='*',
        action='append',
        help='All options after "--" will be passed to CodeNarc',
    )

    parsed_args = arg_parser.parse_args(args)

    if not parsed_args.codenarc_version:
        raise ValueError('Could not determine CodeNarc version')
    if not parsed_args.gmetrics_version:
        raise ValueError('Could not determine GMetrics version')
    if not parsed_args.slf4j_version:
        raise ValueError('Could not determine SLF4J version')

    parsed_args.codenarc_options = [
        option for sublist in parsed_args.codenarc_options for option in sublist
    ]

    logging.basicConfig(
        format='%(levelname)s %(message)s',
        level=parsed_args.log_level or logging.INFO,
        stream=sys.stdout,
    )

    return parsed_args


def parse_xml_report(xml_text):
    """Parse XML report text generated by CodeNarc.

    :param xml_text: Raw XML text of CodeNarc report.
    :return: 0 on success, 1 if any violations were found
    """
    logging.debug('Parsing report XML')
    xml_doc = ElementTree.fromstring(xml_text)

    package_summary = xml_doc.find('PackageSummary')
    logging.info('Scanned %s files', package_summary.attrib['totalFiles'])
    total_violations = _print_violations_in_packages(xml_doc.findall('Package'))

    if total_violations != 0:
        raise CodeNarcViolationsException(total_violations)


def run_codenarc(args, report_file=DEFAULT_REPORT_FILE):
    """Run CodeNarc on specified code.

    :param args: Parsed command line arguments.
    :param report_file: Name of report file to generate.
    :return: Raw XML text report generated by CodeNarc.
    """
    slf4j_log_level = {logging.DEBUG: 'debug', logging.WARN: 'warn', None: 'info'}[
        args.log_level
    ]

    # -rulesetfiles must not be an absolute path, only a relative one to the CLASSPATH
    codenarc_call = [
        'java',
        '-Dorg.slf4j.simpleLogger.showThreadName=false',
        f'-Dorg.slf4j.simpleLogger.defaultLogLevel={slf4j_log_level}',
        '-classpath',
        _build_classpath(args),
        'org.codenarc.CodeNarc',
        '-rulesetfiles=ruleset.groovy',
        f'-report=xml:{report_file}',
    ] + args.codenarc_options

    logging.debug('Executing CodeNarc command: %s', ' '.join(codenarc_call))
    output = subprocess.run(
        codenarc_call, check=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE
    )

    # Trim out empty lines which CodeNarc prints in its output.
    codenarc_output = [x for x in output.stdout.decode().split('\n') if x != '']
    # The last line of CodeNarc's output is (usually) a summary line, which is printed to
    # stdout and not through SLF4J. We save it to a variable and log it with an assigned
    # log level after printing out everything else. If CodeNarc fails due to some other
    # problem, it will not print this line, however.
    codenarc_summary = None
    if codenarc_output[-1].startswith('CodeNarc completed:'):
        codenarc_summary = codenarc_output.pop()

    _log_codenarc_output(codenarc_output)

    if codenarc_summary:
        logging.debug(codenarc_summary)
    logging.debug('CodeNarc returned with code %d', output.returncode)

    # CodeNarc doesn't fail on compilation errors, it just logs a message for each file
    # that could not be compiled and generates a report for everything else. It also does
    # not return a non-zero code in such cases. For our purposes, we want to treat syntax
    # errors (and similar problems) as a failure condition.
    if 'Compilation failed' in str(output.stdout):
        _remove_report_file(report_file)
        raise ValueError('Error when compiling files!')

    if output.returncode != 0:
        _remove_report_file(report_file)
        raise ValueError(f'CodeNarc failed with return code {output.returncode}')
    if not os.path.exists(report_file):
        _remove_report_file(report_file)
        raise ValueError(f'{report_file} was not generated, aborting!')

    logging.debug('Reading report file %s', report_file)
    with open(report_file) as xml_file:
        xml_text = xml_file.read()
    _remove_report_file(report_file)

    return xml_text


if __name__ == '__main__':
    try:
        parse_xml_report(run_codenarc(parse_args(sys.argv[1:])))
        logging.info('No violations found')
    except CodeNarcViolationsException as exception:
        logging.error('Found %s violation(s)', exception.num_violations)
        sys.exit(1)
